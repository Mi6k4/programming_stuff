DAG - directed acyclic graph - ацикличный ориентированный граф

даг - последовательность тасков

Даг это операторы
Операторы могут быть питоновские, башевские, посгресовские и так далее

Таск - пайтон операторы, любые пайтон скрипты или код.
 

Веб сервер
Это пользовательский интерфейс Airflow, построенный на Flask, который предоставляет обзор общего состояния различных DAG и 
помогает визуализировать различные компоненты и состояния каждой DAG. Для настройки Airflow веб-сервер также позволяет вам управлять пользователями,
 ролями и различными конфигурациями.


Шедулер
Каждые n секунд планировщик просматривает DAG и планирует выполнение задачи.

Экзекьютор
Экзекьюторыи — это компоненты, которые фактически выполняют(запускают) задачи, в то время как Планировщик управляет ими. 
Airflow имеет различные типы исполнителей, включая SequentialExecutor, LocalExecutor, CeleryExecutor и KubernetesExecutor.
 Люди обычно выбирают исполнителя, который лучше всего подходит для их случая использования.

Воркер
Воркер несут ответственность за выполнение задачи, которую дал им исполнитель.

База данных метаданных
Airflow поддерживает широкий спектр баз данных для хранения метаданных. 
Эта база данных содержит информацию о DAG, их запусках и других конфигурациях Airflow, таких как пользователи, роли и подключения.
Состояния и запуски DAG отображаются веб-сервером из базы данных. Эта информация также обновляется планировщиком в базе данных метаданных.

Типы исполнителей
SequentialExecutor
SequentialExecutor одновременно выполняет только одну задачу. Планировщик и рабочие используют одну и ту же машину.
Локальный исполнитель
LocalExecutor аналогичен Sequential Executor, за исключением того, что он может запускать несколько задач одновременно.
CeleryExecutor
Celery — это среда Python для выполнения распределенных асинхронных задач.
В результате CeleryExecutor долгое время был частью Airflow, еще до Kubernetes.
CeleryExecutors имеет фиксированное количество рабочих в режиме ожидания, чтобы взять на себя задачи, когда они станут доступны.
KubernetesExecutor
Каждая задача выполняется KubernetesExecutor в собственном модуле Kubernetes. 
Он, в отличие от Celery, запускает рабочие модули по запросу, что позволяет наиболее эффективно использовать ресурсы.



В: Каковы плюсы и минусы SequentialExecutor?
Ответ:
Плюсы:

Это просто и понятно настроить.
Это хороший способ протестировать DAG во время их разработки.

Минусы:
Это не масштабируется.
Невозможно выполнять много задач одновременно.
Непригоден для использования в производстве



Q: Каковы плюсы и минусы LocalExecutor?
Ответ:
Плюсы:
Умеет выполнять несколько задач.
Может использоваться для запуска DAG во время разработки.

Минусы:
Продукт не масштабируется.
Есть только одна точка отказа.
Непригоден для использования в производстве.

В: Каковы плюсы и минусы CeleryExecutor?
Ответ:
Плюсы:
Это обеспечивает масштабируемость.
Селери отвечает за управление рабочими. Celery создает новый в случае сбоя.

Минусы:
Celery требует RabbitMQ/Redis для постановки задач в очередь, что избыточно по сравнению с тем, что уже поддерживает Airflow.
Настройка также усложняется из-за вышеупомянутых зависимостей.

В: Каковы плюсы и минусы KubernetesExecutor?
Ответ:
Плюсы:
Он сочетает в себе преимущества CeleryExecutor и LocalExecutor с точки зрения масштабируемости и простоты.
Детальный контроль над ресурсами распределения задач. На уровне задачи можно настроить необходимый объем ЦП/памяти.

Минусы:
Airflow новее для Kubernetes, и документация у него сложная.



Класс DAG Python в Airflow позволяет создавать направленный ациклический граф, который является представлением рабочего процесса.


Вы можете использовать дату начала, чтобы запустить задачу в определенную дату.
Интервал расписания указывает, как часто запланирован запуск каждого рабочего процесса. '* * * * *' указывает, что задачи должны выполняться каждую минуту.


Вопрос. Как сделать модуль доступным для воздушного потока, если вы используете Docker Compose?
Ответ:
Если мы используем Docker Compose, нам нужно будет использовать собственный образ с нашими собственными дополнительными зависимостями, 
чтобы сделать модуль доступным для Airflow. Обратитесь к следующей документации по воздушному потоку, чтобы узнать, зачем нам это нужно и как это сделать.

В: Как запланировать DAG в Airflow?
Ответ:
DAG можно запланировать, передав выражение timedelta или cron (или одно из предустановленных значений @),
 что достаточно хорошо работает для DAG, которые необходимо запускать на регулярной основе, но есть много других вариантов использования,
 которые в настоящее время трудно выразить. изначально» в Airflow или которые требуют сложных обходных путей.
 Вы можете обратиться к предложениям по улучшению воздушного потока (AIP).

Что такое XComs в воздушном потоке?
Ответ:
XCom (сокращение от кросс-коммуникации) — это сообщения, которые позволяют передавать данные между задачами. 
Ключ, значение, метка времени и идентификатор задачи/DAG определены.

Что такое xcom_pull в XCom Airflow?
Ответ:
Методы xcom push и xcom pull в экземплярах задач используются для явного «проталкивания» и «вытягивания» XCom в их хранилище и из них. 
В то время как если для параметра do xcom push установлено значение True (по умолчанию), многие операторы и функции 
@task будут автоматически отправлять свои результаты в ключ XCom с именем return value.

Если для xcom pull не указан ключ, он будет использовать этот ключ по умолчанию, что позволит вам написать такой код:

В: Что такое шаблоны Jinja?
Ответ:
Jinja — это быстрый, выразительный и расширяемый механизм шаблонов. 
В шаблоне есть специальные заполнители, которые позволяют вам писать код, похожий на синтаксис Python.
 После этого данные передаются в шаблон, чтобы отобразить окончательный документ.

В: Как использовать Airflow XComs в шаблонах Jinja?
Ответ:
Мы можем использовать XComs в шаблонах Jinja, как показано ниже:


xcom лежит в базе аирфлоу


python branch operator почитать


sensor айрфлоу
операторы прочитать